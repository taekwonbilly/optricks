enum Open{
	Read
	Write
	Append
}

class primitive File{
        lang.c.pointer f;
        def File(lang.c.string s, lang.c.string t='r'){
        	this.f = (extern lang.c.pointer fopen(lang.c.string, lang.c.string))(s,t);
        };
	static def File popen(lang.c.string c, lang.c.string t){
		return (extern File popen(lang.c.string,lang.c.string))(c,t);
	}
        def void flush(){
                (extern void fflush(lang.c.pointer))(this.f);
        };
        def void close(){
                this.flush();
                (extern lang.c.int fclose(lang.c.pointer))(this.f);
        };
	def write(lang.c.int c){
		(extern lang.c.int fputc(lang.c.int,lang.c.pointer))(c, this.f);
		return this;
	};
        def print(char c){
                (extern lang.c.int fputc(char,lang.c.pointer))(c, this.f);
                return this;
        };
        def print(lang.c.string c){
                (extern lang.c.int fputs(lang.c.string, lang.c.pointer))(c,this.f);
                return this;
        };
	def println(){
		this.print('\n');
	}
	def println(char c){
		this.print(c);
		this.print('\n');
	};
	def lang.c.int read(){
		return (extern lang.c.int fgetc(lang.c.pointer))(this.f);
	}

};

class primitive Base64File{
	int buf;
	byte len;
	def Base64File(){
		this.len = 0;
		this.buf = 0;
	}
	static def encode(int b){
		return ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/'][b];
	}
        def void close(){
		if(this.len!=0){
			if(this.len==1) this.buf << 16;
			if(this.len==2) this.buf << 8;
			auto idx1 = this.buf >> 18;
			auto idx2 = (this.buf >> 12) & 0b111111;
			auto idx3 = (this.buf >> 6) & 0b111111;
			auto idx4 = this.buf & 0b111111;
			print(Base64File.encode(idx1));
			print(Base64File.encode(idx2));
			print(Base64File.encode(idx3));
			print(Base64File.encode(idx4));
		}
        };
	def write(lang.c.int c){
		this.buf = (this.buf << 8) | c;
		this.len++;
		if(this.len==3){
			auto idx1 = this.buf >> 18;
			auto idx2 = (this.buf >> 12) & 0b111111;
			auto idx3 = (this.buf >> 6) & 0b111111;
			auto idx4 = this.buf & 0b111111;
			print(Base64File.encode(idx1));
			print(Base64File.encode(idx2));
			print(Base64File.encode(idx3));
			print(Base64File.encode(idx4));
			this.buf = 0;
			this.len = 0;
		}
	};
};

extern lang.c.size_t strlen(lang.c.string);
extern lang.c.string strcpy(lang.c.string,lang.c.string);

def getInfo(lang.c.string s){
	FileStat fs;
	(extern lang.c.int stat(lang.c.string, FileStat&))(s,&fs);
	println(fs.isFile());
	println(fs.isDirectory());
	println(fs.getSize());

}
def isFile(lang.c.string s){
	FileStat fs;
	(extern lang.c.int stat(lang.c.string, FileStat&))(s,&fs);
	return fs.isFile();
}

extern void fflush(lang.c.pointer=null);


def lang.c.string[] listdir(lang.c.string s){
	lang.c.string[] ar = lang.c.string[](0);
	auto mlen = strlen(s);
	bool end=s[mlen-1]=='/';

	auto dir = (extern lang.c.pointer opendir(lang.c.string))(s);
	do{
		auto st = _posix_dir_next_name(dir);
		if(st==null) break;

		auto len = mlen+strlen(st)+(end?lang.c.size_t(1):lang.c.size_t(2));
		auto cp = (extern lang.c.string malloc(lang.c.size_t))(len);

		if(end)
			sprintf(cp,"%s%s",s,st)
		else
			sprintf(cp,"%s/%s",s,st)

		if(isFile(cp)) {
			ar[]= cp;
		}
		else { 
			(extern void free(lang.c.pointer))(cp);
		}
	}while(true);
	(extern void closedir(lang.c.pointer))(dir);

	return ar;
}
